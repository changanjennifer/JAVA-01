##### 第7周作业：

1. ##### (选做）用今天上课学习的知识，分析自己系统的SQL和表结构

   之前对数据库的设计不严谨，

   各个table的id 和状态栏位，命名不一致，会给维护带来一定的不便。

   对此作了变更。

   统一将各个表的主键栏位改为id, 状态栏位改为 status. 

   另外，为了方便本次的作业测试，增加了一个新的表simpleorders, 一笔订单只包含一笔商品（即不是主表明细表形式记录），更新了上周的sql文件。

2. ##### (必做）按自己设计的表结构，插入100万订单模拟资料，测试不同方式的插入效率

   ###### 基础资料：

   ```
   分类Category：1000种分类
   商品goods:  1万种商品（为了简化，暂定商品都属于同一个商铺)，
   客户customer: 10万笔客户资料. 
   之后插入100万笔订单simpleorders，这些订单资料生成时，会从1万客户中，随机选择一个，并从10万种商品中，随机选择一种商品。(10万商品资料会先查询并cache起来)
   ```

   ###### 新增100万笔订单资料的程序为  com.yhh.ecommerce.GenerateOrders.java  ， 

   采用Preparestatement 编译插入的SQL ,用单笔执行方式,耗时 549s, 约9分钟左右：

   采用Preparestatement 的ExecuteBatch ()方法，

   ​     每次提交1000笔，提交1000次效率高， 350秒

   ​    将主键改为自增：

   ​     在循环中生成数据，每次提交1万笔资料，提交100次，耗时约： 160~220秒，约2.5~4分钟。

   ​     每次提交10万笔资料，提交10次， 耗时：300以上秒

    结论：用 BatchExecute的效率高于单笔执行的方式， 并且批次执行，批次发送的SQL在某个范围效率较高。（粗略计算，一笔insert 的SQL,  语句+数据有500byte左右，10000完笔刚刚超过4M，可能需要调整mysql的相关buffer的参数）.

   

##### 第14节课作业：（尚未完成）

作业2.（必做）读写分离-动态切换数据源版本1.0

作业3.（必做）读写分离-数据库框架版本2.0

作业4（选做）读写分离--数据库中间件版本3.0





