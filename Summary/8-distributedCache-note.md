### 分布式缓存知识点总结



#### **为什么引入缓存**？

##### 数据库缓存需求

传统的后端业务场景中，访问量以及对响应时间的要求均不高，通常只使用DB即可满足要求。这种架构简单，便于快速部署，很多网站发展初期均考虑使用这种架构。但是随着访问量的上升，以及对响应时间的要求提升，单DB无法再满足要求。

内存的访问性能明显优于磁盘。把数据放入内存中，可以提供更快的读取效率。但在互联网业务的场景下，将所有数据数据都装入内存，显然是不明智的。同时大部分的业务场景下，80%的访问量都集中在20%的热数据上(适用二八原则)。因此，通过引入缓存组件，将高频访问的数据，放入缓存中，可以大大提高系统整体的承载能力，原有单层DB的数据存储结构，也变为Cache+DB的结构。

在数据层引入缓存，有以下几个好处：

- 提升数据读取速度
- 提升系统扩展能力，通过扩展缓存，提升系统承载能力
- 降低存储成本，Cache+DB的方式可以承担原有需要多台DB才能承担的请求量，节省机器成本

根据业务场景，通常缓存有以下几种使用方式

- 懒汉式(读时触发)：写入DB后, 然后把相关的数据也写入Cache
- 饥饿式(写时触发)：先查询DB里的数据, 然后把相关的数据写入Cache
- 定期刷新：适合周期性的跑数据的任务，或者列表型的数据，而且不要求绝对实时性

 

**分布式缓存实现**

构建大型互联网系统会面临很多的挑战，主要有：

- 百万级QPS的资源调用 (高并发)
- 99.99%的可用性 (高可用)
- 毫秒级的核心请求响应时间 (高性能)

设计这样的互联网系统，不可避免的要考虑使用分布式缓存，并从可用性、并发性、性能多个方面进行综合考量。



#### 缓存的更新模式：



#### 缓存失效策略

一般而言，缓存系统中都会对缓存的对象设置一个超时时间，避免浪费相对比较稀缺的缓存资源。对于缓存时间的处理有两种，分别是主动失效和被动失效。

-  主动失效：主动失效是指系统有一个主动检查缓存是否失效的机制，比如通过定时任务或者单独的线程不断的去检查缓存队列中的对象是否失效，如果失效就把他们清除掉，避免浪费。主动失效的好处是能够避免内存的浪费，但是会占用额外的CPU时间。
-  被动失效：被动失效是通过访问缓存对象的时候才去检查缓存对象是否失效，这样的好处是系统占用的CPU时间更少，但是风险是长期不被访问的缓存对象不会被系统清除。

 

#### 缓存淘汰策略

缓存淘汰，又称为缓存逐出(cache replacement algorithms或者cache replacement policies)，是指在存储空间不足的情况下，缓存系统主动释放一些缓存对象获取更多的存储空间。 

对于大部分内存型的分布式缓存（非持久化），淘汰策略优先于失效策略，一旦空间不足，缓存对象即使没有过期也会被释放。这里只是简单介绍一下，相关的资料都很多，一般LRU用的比较多。

-  FIFO：先进先出（First In First Out）是一种简单的淘汰策略，缓存对象以队列的形式存在，如果空间不足，就释放队列头部的（先缓存）对象。一般用链表实现。
-  LRU：最近最久未使用（Least Recently Used），这种策略是根据访问的时间先后来进行淘汰的，如果空间不足，会释放最久没有访问的对象（上次访问时间最早的对象）。比较常见的是通过优先队列来实现。 

- LFU：最近最少使用（Least Frequently Used），这种策略根据最近访问的频率来进行淘汰，如果空间不足，会释放最近访问频率最低的对象。这个算法也是用优先队列实现的比较常见。

 

#### **分布式缓存的常见问题**

**缓存穿透**

-  DB中不存在数据，每次都穿过缓存查DB，造成DB的压力。一般是网络攻击
- 解决方案：放入一个特殊对象（比如特定的无效对象，当然比较好的方式是使用包装对象）

**缓存击穿**

- 在缓存失效的瞬间大量请求，造成DB的压力瞬间增大
- 解决方案：更新缓存时使用分布式锁锁住服务，防止请求穿透直达DB

**缓存雪崩**

- 大量缓存设置了相同的失效时间，同一时间失效，造成服务瞬间性能急剧下降
- 解决方案：缓存时间使用基本时间加上随机时间